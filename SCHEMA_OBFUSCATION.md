# Schema Obfuscation Security Layer

## Overview

The Schema Obfuscation layer is a hybrid security feature that protects your real database schema while maintaining semantic meaning for optimal LLM performance. This approach provides enterprise-grade security without sacrificing query generation quality.

## 🔐 Security Benefits

- **Schema Protection**: Real table and column names are never exposed to the LLM
- **Semantic Preservation**: Obfuscated names maintain clear meaning (e.g., `real_estate_items` instead of abstract `entity_a`)
- **Validation**: Automatic detection if LLM accidentally uses real schema names
- **Auditability**: Clear separation between obfuscated and real SQL for debugging
- **Flexibility**: Easy to modify real schema without retraining LLM

## 🏗️ Architecture

```
User Query → LLM (with obfuscated schema) → Obfuscated SQL → Translation Layer → Real SQL → Snowflake
```

### Key Components

1. **SchemaObfuscator** (`src/utils/schema_obfuscator.py`)
   - Bidirectional translation between real and obfuscated names
   - Security validation 
   - Schema info generation for LLM prompts

2. **Enhanced NLP Agent** (`src/agent/nlp_agent.py`)
   - Updated prompt with obfuscated schema
   - Automatic translation integration
   - Enhanced logging and error handling

## 📋 Schema Mapping

### Table Mappings
| Real Name | Obfuscated Name | Purpose |
|-----------|-----------------|---------|
| `properties` | `real_estate_items` | Property information |
| `locations` | `geographic_areas` | Location data |
| `agents` | `sales_representatives` | Agent information |
| `transactions` | `commercial_events` | Transaction records |
| `owners` | `property_holders` | Owner information |

### Key Column Mappings
| Real Name | Obfuscated Name | Description |
|-----------|-----------------|-------------|
| `property_id` | `item_id` | Property identifier |
| `location_id` | `area_ref` | Location reference |
| `price` | `monetary_value` | Property price |
| `bedrooms` | `sleeping_rooms` | Number of bedrooms |
| `bathrooms` | `bath_facilities` | Number of bathrooms |
| `sqft` | `floor_area` | Square footage |
| `agent_id` | `rep_id` | Agent identifier |
| `transaction_count` | `deal_count` | Transaction count |

## 🔄 Query Flow Example

### User Input
```
"¿Cuáles son las propiedades más caras por ciudad?"
```

### LLM Generates (Obfuscated)
```sql
SELECT ga.city_name, rei.monetary_value, rei.item_id
FROM real_estate_items rei
JOIN geographic_areas ga ON rei.area_ref = ga.area_id
WHERE rei.monetary_value > 500000
ORDER BY rei.monetary_value DESC
LIMIT 10
```

### System Translates to Real SQL
```sql
SELECT l.city, p.price, p.property_id
FROM properties p
JOIN locations l ON p.location_id = l.location_id
WHERE p.price > 500000
ORDER BY p.price DESC
LIMIT 10
```

### Executes Against Snowflake
Real SQL is executed and results are returned to user.

## 🛡️ Security Features

### 1. Validation
- Checks that LLM-generated SQL uses only obfuscated names
- Flags security violations when real schema names are detected
- Provides detailed violation reports

### 2. Translation
- Robust bidirectional translation with regex-based replacement
- Handles qualified (`table.column`) and unqualified (`column`) references
- Preserves SQL structure and functions

### 3. Error Handling
- Graceful fallback if translation fails
- Enhanced error context for debugging
- Specific error types for schema-related issues

## 🧪 Testing

Run the comprehensive test suite:

```bash
python test_obfuscation.py
```

Tests cover:
- ✅ Basic translation (real ↔ obfuscated)
- ✅ Complex JOINs with multiple tables
- ✅ Security validation (real names detection)
- ✅ Aggregation queries (GROUP BY, HAVING)
- ✅ Window functions (RANK, ROW_NUMBER)
- ✅ Schema info generation

## 🚀 Usage

The obfuscation layer is automatically integrated into the NLP agent. No changes required in your application code.

### Query Processing
```python
# Your existing code works unchanged
agent = SnowflakeNLPAgent(db_connection_string)
result = agent.process_query("¿Cuántas propiedades hay?")

# Results now include additional security info
print(result['security_layer'])      # "obfuscated"
print(result['obfuscated_sql'])      # SQL generated by LLM
print(result['real_sql'])           # SQL executed on database
```

### Debug Information
```python
# Enhanced logging shows the security workflow
agent.process_query("Muéstrame agentes con más ventas")

# Log output:
# 🔐 Obfuscated SQL generated: SELECT rep_id, deal_count FROM sales_representatives...
# 🔄 Translated to real SQL: SELECT agent_id, transaction_count FROM agents...
# 🚀 Executing real SQL: SELECT agent_id, transaction_count FROM agents...
# ✅ Results obtained: 10 rows
```

## ⚙️ Configuration

### Adding New Mappings
To add new tables or columns, update `src/utils/schema_obfuscator.py`:

```python
# Add to TABLE_MAPPING
'new_table': 'obfuscated_new_table'

# Add to COLUMN_MAPPING  
'new_table.new_column': 'obfuscated_new_table.obfuscated_column'
```

### Security Levels
Current implementation uses **Hybrid Obfuscation**:
- ✅ Semantic meaning preserved
- ✅ Real names hidden
- ✅ Easy maintenance

For maximum security, consider implementing **Complete Abstraction**:
- All names become `entity_a`, `entity_b`, etc.
- Higher security but reduced LLM understanding
- More complex to implement and maintain

## 📊 Performance Impact

- **Translation overhead**: ~2-5ms per query
- **Memory usage**: Minimal (mappings loaded once)
- **Query quality**: Maintained or improved due to semantic clarity
- **Debugging**: Enhanced with dual SQL logging

## 🔧 Troubleshooting

### Common Issues

1. **Security Violations**
   ```
   ⚠️ Security violation in SQL: Real schema names detected: ['properties', 'property_id']
   ```
   **Solution**: LLM used real names. Check prompt or retrain if persistent.

2. **Translation Errors**
   ```
   ❌ Error translating obfuscated SQL: invalid regex pattern
   ```
   **Solution**: Check for special characters in SQL or mapping definitions.

3. **Missing Mappings**
   ```
   🔄 Column 'new_field' not found in mapping
   ```
   **Solution**: Add new column mappings to `COLUMN_MAPPING` dictionary.

## 🎯 Best Practices

1. **Regular Testing**: Run test suite after schema changes
2. **Monitor Logs**: Watch for security violations or translation errors  
3. **Update Mappings**: Keep obfuscated names semantically meaningful
4. **Document Changes**: Update this documentation when adding mappings
5. **Backup**: Always test in development before production deployment

## 🔮 Future Enhancements

- **Dynamic Mapping**: Auto-generate obfuscated names from schema
- **Role-based Security**: Different obfuscation levels per user
- **Audit Logging**: Track all obfuscated queries for compliance
- **Performance Optimization**: Cache translations for repeated queries
- **Multi-tenant Support**: Different mappings per tenant/database

---

**Security Note**: This obfuscation layer provides significant protection against accidental schema exposure. For maximum security in highly sensitive environments, consider implementing the complete abstraction approach with entity-based naming.